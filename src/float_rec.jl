
using LinearAlgebra
using SparseArrays
using Nemo
using Distributions
using AbstractAlgebra

#------------------------------------------------------------------------------

function unit_vector(n, i, ground)
    reshape([
        j == i ? ground(1) : ground(0)
        for j in 1:n
    ], (n, ))
end

# factorizes the given matrix `A` by the subspace generated by vector `v`
# Returns new, factorized representation of the matrix
function factorize(A, v)
    n = size(A, 1)
    ground = AbstractAlgebra.QQ

    VSpace = AbstractAlgebra.Generic.MatrixSpace(ground, n, 1)
    MSpace = AbstractAlgebra.Generic.MatrixSpace(ground, n, n - 1)
    MSpaceplus = AbstractAlgebra.Generic.MatrixSpace(ground, n, n)

    # complement ⊕ v = Rn
    pivot = findfirst(!iszero, v)
    complement = []
    for j in 1:n
        if j == pivot
            continue
        end
        push!(complement, VSpace(unit_vector(n, j, ground)))
    end

    # Asvs = [A*f1 A*f2 .. Afd]
    # for fi in complement
    Avs = MSpace(hcat([MSpaceplus(A) * v for v in complement ]...))

    # matrix = [f1 f2 .. fd e1]
    # for fi in complement
    matrix = MSpaceplus(hcat(complement..., VSpace(v)))

    # solve for each A from As
    #   A*fi = a1*f1 + a2*f2 + ... + ad*fd + e
    #   where e ∈ <v>
    ans = Array(AbstractAlgebra.Generic.solve(matrix, Avs)[1:end-1, :])
    return ans, [Array(x) for x in  complement]
end

# lifts vector `v` to the subspace generated by vectors `Vs`
# Returns new, lifted representation of the vector
function Nemo.lift(x, Vs)
    n = size(first(Vs), 1)
    ground = AbstractAlgebra.QQ

    lifted_vector = zeros(ground, n)
    println(Vs)

    for i in 1:size(v, 1)
        lifted_vector = lifted_vector + v[i]*Vs[i]
    end

    lifted_vector
end

#------------------------------------------------------------------------------

# "Rational numbers with bound denominators are discrete!"

# for the given float `y` and natural `M`
# computes rational fraction `p/q` approximating `y` such that
#   |p/q - y| < 1/(2M²)
#       and
#   q ≤ M
# i.e the fraction `p/q` with the simplest denominator closest to `y`
function float_reconstruction(y::T, M) where {T<:AbstractFloat}
    # the function implements algorithm derived from Corollary 6.3a
    # in Theory of Linear and Integer Programming, Schrijver, 1986,
    # the notation is taken from there

    ε = eps(T)

    αβ = [abs(y), 1]
    A = [BigInt[1, 0], BigInt[0, 1]]

    k = 1
    # standard Extended Euclidean algorithm until q < M
    while true
        # determine the order of columns
        i, j = iseven(k) ? (1, 2) : (2, 1)

        abs(A[j][1]) > M && break

        k += 1

        # in case the float `y` is rational exactly (w.r.t to ε)
        isapprox(αβ[j], T(0), atol=ε, rtol=0) && break

        # EEA step
        t = floor(BigInt, αβ[i] / αβ[j])
        A[i] -= t * A[j]
        αβ[i] -= t * αβ[j]
    end

    i, j = iseven(k) ? (1, 2) : (2, 1)
    return -Int(sign(y)) * A[i][2] // A[i][1]
end

#------------------------------------------------------------------------------

function inner(x, y)
    sum(x .* y)
end

function rayleigh(A, x)
    inner(A * x, x) / inner(x, x)
end

function power_iteration(A; err=200)

    n = size(A, 1)

    M = BigFloat(err)

    x = ones(BigFloat, n)
    r = x

    i = 0
    while i < 50 && maximum(abs.(r)) > 1 / (2err^2)
        @info "$i th: $( maximum(abs.(r)) )"

        Ax = A * x
        x = Ax / norm(Ax)
        r = rayleigh(A, x)*x - A * x

        i += 1
    end

    rayleigh(A, x), x
end

function find_1_eigv(A)

    M = 100

    a, x = power_iteration(Float64.(A), err=M)
    a_rec = float_reconstruction(a, M)
    x_rec = [ float_reconstruction(xi, M) for xi in x ]

    return a_rec, x_rec
end

function find_all_eigv(A)
    n = size(A, 1)
    eigval = []
    eigvec = []
    ground = AbstractAlgebra.QQ

    C = [ unit_vector(n, i, ground) for i in 1:n ]

    while size(A, 1) > 1
        println("------------------\n")
        println(A)

        a, v = find_1_eigv(A)

        v = lift(v, C)
        A, C = factorize(A, v)

        push!(eigval, a)
        push!(eigvec, v)
    end

    return eigval, eigvec
end

invC = 1
A = 1
D = 1

function test1()

    global invC
    global A, D, C, a, x

    n = 4
    C = floor.(BigInt, 2*randn(n, n)) .// (abs.(floor.(BigInt, 3*randn(n, n))) .+ 1)
    for i in 1:n
        for j in 1:n
            if i < j
                C[i, j] = 0
            end
        end
        C[i, i] = 1
    end

    D = diagm(sort(floor.(BigInt, 3*randn(n)), by= (x -> -x) ∘ abs))
    D[1, 1] = maximum(abs.(D)) + 1

    invC = C
    for i in 1:n
        for j in 1:n
            if i > j
                invC[i, j] = -invC[i, j]
            end
        end
    end
    println(C * invC)

    A = C * D * invC

    a, x = find_1_eigv(A)

    @info a

end

test1()
